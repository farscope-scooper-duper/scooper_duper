#Needed functionality:
# - Publish and subscribe to the appropriate topics

# - Test/calibrate/wait to start

# - Timers
#  - Overall runtime timer
#  - Reach/travel timers

# - Request an item from the item selector
# - Signal pick failure/success to the item selector/world model

# - Send positions and poses to the motion executor, wait for response or break after limit

import rospy
import time
from std_msgs.msg import String,Bool,Int8
from geometry_msgs.msg import Transform,Vector3,Quaternion
#from scooper_duper.msg import *
from json_handler import *

def c_loop_vision_callback(data):
	rospy.loginfo("Control loop recieved data from topic items_in_view");
	rospy.loginfo(data);

def c_loop_gripsensor_callback(data):
	rospy.loginfo("Control loop recieved from topic grip_sensor");
	rospy.loginfo(data);

#==Test routine==
print("Running connection tests...")
print("Connection tests complete.")

#==Calibration and setup==
print("Running setup and calibration...")

#Read in the pick file, set up world model.
world_model = WorldModel('pick_list.json')

#Set up ros communications
rospy.init_node('control_loop', anonymous=True)
finger_pos_pub = rospy.Publisher('finger_pos', Bool, queue_size=10)
suction_state_pub = rospy.Publisher('suction_state', Bool, queue_size=10)
EE_pose_pub = rospy.Publisher('t_EE_pose', Transform, queue_size=10)

#rospy.Subscriber("items_in_view", ItemList , c_loop_vision_callback)
rospy.Subscriber("grip_sensor", Int8 , c_loop_gripsensor_callback)
rate = rospy.Rate(0.5) # 10hz

#==Wait for operator's confirmation to start==
operator_input = raw_input("Please type 'begin' to start operations: ")
while (operator_input.lower() != "begin"):
    operator_input = raw_input("Invalid input. Please type 'begin' to start: ")

#==Request next item==
target_item = world_model.pick_list[0]
target_item_bin = world_model.bins_of(target_item)[0] #If there are multiple bins for some reason, just take the first

#==Provide motion executor with target item bin location==
#Need a lookup list of the bin locations (should be generated by the calibration routine)
op_start_time = time.time()
while (time.time() - op_start_time):
    #Wait for indication that the end effector has reached the bin



